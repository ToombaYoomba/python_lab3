# Лабораторная №1 "калькулятор". Сложность М2. Морхов Захар Александрович. М80-101БВ-25

## Задача
Создание калькулятора на питоне, который:
- принимающет математическое выржение в инфиксной записи
- токенизирует числа и операции
- перобразует его в обратную польскую запись
- вычисляет его стэком


## Структура проекта

 <pre>
    .
    ├── lab<# лабораторной работы>             # Кодовая база лабораторной работы
    │   ├── src/                               # Исходный код
    │   ├── tests/                             # Pytests
    │   ├── uv.lock                            # зависимости проекта
    │   ├── report.pdf                         # Отчет
    │   ├── .gitignore                         # git ignore файл
    │   ├──.pre-commit-config.yaml             # Средства автоматизации проверки кодстайла
    │   ├── README.md                          # Описание проекта, с описанием файлов и с титульником о том,
                                               # что и какая задача
    │   ├── .vscode                            # настройки vscode
</pre>


## Ввод

Пользователь активирует файл [main.py](./src/main.py) через ввод команды `py -m src.main` в терминале 
Далее пользователь вводит математическое выражение, состоящее из:
- Операндов (Все вещественные числа)
- Операторов:
- - Сложение +
  - Вычетание -
  - Умножение *
  - Деление / 
  - Возведение в степень **
  - Деление нацело //
  - Остаток от деления %
 
Приоритеты операций: 1) унарные; 2) ** (право-ассоц.); 3) * / // %; 4) + -. 
 
После работы программа печатает ответ - вещественное число, округлённое до 6-го знака

## Алгоритм

Алгоритм представляет собой последовательность выполнения следующиз основных функций в файле [main.py](./src/main.py):
1. `parse()` из [parse.py](./src/parse.py) - парсирует входное выражение, разбивая его на токены для чисел и операций
2. `check_mistakes()` из [errors.py](./src/errors.py) - проверяет парсированное выражение на ошибки синтаксиса
3. `to_polish()` из [to_polish.py](./src/to_polish.py) - переводит выражение в обратную польскую запись
4. `calc_polish()` из [to_polish.py](./src/calc_polish.py) - подсчитывает выражение в польской записи и выдаёт ответ на него

## Мои решения

### Парсинг
Функция `parse()` на токены разбивает их на два типа: `("NUM", float(x))` и `("operation", None)` для избежания создания шаблонов двух токенов и сохранения чёткой типизации `Token = (str, float | None)`. Сам шаблон парсинга лежит в константе `TOKEN_RE`, где я выделяю числа с унарными знаками и операции. Это удобно, так как позволяет не добавлять лишние проверки на унарные знаки, а сделать парсинг числа со знаком, если они находятся вплотную (например -1). То есть запись `1+1` будет парсированна как `[("NUM", 1.0), ("NUM", 1.0)]`. Это сделано для унификации парсинга положительных и отрицательных унарных знаков, так что при использовании сложения или вычитания, они должны быть отделены от последующих / предыдущих чисел. Для реализации функции и токенизации были использованы функции `re.compile()` и `re.match()` из библиотеки `re`. 

### Проверка ошибок
В файле [errors.py](./src/errors.py) находится класс для вызова ошибок, а также функция `check_mistakes()`. Она проверяет исходное выражение на ошибки. За ошибки я считал:
- Ошибки, касающиеся ошибочного ввода несокльких чисел \ операций (оператор перед закрывающей скобкой, число перед октрывающей скобкой и т.д.)
- Несовподающее число скобок

Но за ошибку не считается нахождение в скобках числа, что сделано для удобства ввода, так как в обычных умных калькуляторах (например photomath) это не считается ошибкой

Я не делал несколько классов ошибок, так как ошибки для их отслеживания можно прописать в одном классе. Исключение - ошибки, связанные со стэками, так как они используют стандартные действия со списками, вызывающими ошибку `InexError()` (далее в документации)

### Перевод в обратную польскую запись
Функция `to_polish()` переводит обычную запись в обратную польскую нотацию. Она это делает по стандартному алгоритму перевода через стэк с учётом иерархии операций, находящейся в словаре `HIERARCHY`. Это удобно, так как последующий алгоритм вычисления выражения сильно упрощается, а также перевод учитывает скобки и учитывает унарные знаки, считая числа с ними на равне с обычными. Согласно стандартному алгоритму ввод скобок в стэк имеет свой метод обработки (так как обработка закрывающей скобы выкидывает все операции между скобками в конечный список), но они существуют в константе `HIERARCHY` с наименьшим приоритетом, дабы они всегда ложились поверх любой операции в стэке. Выходом является список токенов, представляющий собой обратную польскую запись.

В переводе, а также подсчёте польской записи используются отдельные команды для работа со стэками в файле [stack.py](./src/stack.py). Они нужны для более удобной и наглядной работы со стэком, а также обработки ошибок при работе с ним.

### Подсчёт польской записи
Функция `calc_polish` подсчитывает запись в обратной польской нотации. Аналогично предыдущей функции она использует стандартный метод посчёта польской записи через стэк. Для вычисления конкретных оперций с числами я сделал функцию `calc()` в файле [calc.py](./src/calc.py). Она получает на вход три токена: два операнда и одну операцию, а дальше применяет к ним сответсующую операцию. При делении на ноль выдаётся ошибка, так же как при проведении операции целения нацело и деления с остатком над нецелыми числами, потому что это невозможно чисто математически и так написано в требованиях к работе. В итоге функция подсчёта полькой записи выдаёт вещественное число, округлённое до 6-го знака для удобства просмотра ответа и наглядности

### Тесты 
Тесты были сделаны при помощи `pytest`, используя прогонку нескольких заданных значений через один тест для удобства тестирования. В тестах учитываются как нормлаьные результаты работы функций, так и крайные варианты, вызвающие ошибки. Для этого используется билиблиотека `contextlib`, из которой взят `nullcontext` под видом `does_not_raise`. Также я использовал `@pytest.mark.parametrize` для удобной прогонки тестов

### Описания функций и стиль кода
Для каждой функции написаны dogstring, а также для важных переменных и действий есть пояснения, а также типы данных на входе и выходе функций. Для приведения кода в порядок я использовал Ruff, который не применяется к файлам из папки [tests](./tests). В коде были оставленны закоменченные функции вывода `print()` для удобства теститрования и проверки формата вывода каждой функции


